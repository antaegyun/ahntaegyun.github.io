---
layout: post
title: "[1]점자시계 프로그래밍"
data: 2018-10-12 16:23:00
author: An Taegyun
categories: Projects
tag: 아두이노
---

대림대학교 3학년 2학기 캡스톤디자인 수업.
시각장애인을 위한 점자시계를 졸업작품 프로젝트로 선정.
시간을 따른 점자의 모양을 표현하기 위해 모터를 제어하는 프로젝트.

### 모터 프로그래밍

점자를 표현하기 위해 DC모터를 오른쪽으로 돌면 막대기가 올라가서 점자가 올라온 것으로 표시되고, 막대기가 올라간 상태에서 왼쪽으로 돌면 막대기가 내려가서 점자가 내려간 것으로 표시된다.

숫자에 따른 점자의 모양, 값을 배열로 선언
```c++
int dotNumber[10] {
  0b00101010, 0b10000000, 0b10001000, 0b10100000, 0b10100010,
  0b10000010, 0b10101000, 0b10101010, 0b10001010, 0b00101000
};
```
모터가 돌아가면서 막대기가 올라가면 모터를 정지시켜주고 내려갈 때에도 동일하다.
이때 이전 모터의 상태와 현재 바꾸어주어야 할 모터의 상태를 비교해서 올려주어야 하는 것과 내려주어야 하는 것을 계산을 통해 한번에 모터 동작을 수행하고 정지시켜 줄 수 있다면 동작도 매우 간결해지고 불필요 한 모터의 동작을 줄일 수 있다고 판단되었다.

## 모터 동작 방식

현재 모터를 동작해주는 방식은 74HC574에 데이터 입력 후 Latch 제어를 통해 모터를 통해 점자를 나타낸다. 74HC574에 output 단자는 총 8개이며 DC모터 4개를 제어 할 수 있다. 이렇게 Latch 제어를 통해 총 모터 16개를 제어 해준다.
ex) 74HC574에 0b00101010 데이터 입력 후 출력이 된다면, 00/10/10/10으로 나누어서 보고 00 = 모터 정지 10 = 모터 올려주는 동작을 할 수 있다. 01 = 모터 내려주는 동작이다.

## 모터 동작 값 추출
이전 모터의 상태는 old_time[arr]라는 배열에 저장되어 있고, 바꾸어 주어야 할 모터의 상태는 new_time[arr]에 저장되어 있다.
일단 올려주어야 할 데이터만 추출하려면 어떻게 해야 할 지 고민을 해보았다.
ex) oldTime[0] = 10100010 이고,
    newTime[0] = 10001010 이라면 곂쳐있는 1은 움직이지 않고 old에는 0 new에는 1이면 올려주어야 한다.

방법은 ~newTime[arr]^oldTime[arr]를 해주면 올려줘야 하는 위치를 찾을 수 있다.
ex) oldTime[0] = 10100010
    newTime[0] = 10001010, ~newTime[0] = 01110101
    ~newTime[0](01110101) ^(XOR)
     oldTime[0](10100010) = 00001000-> up 변수에 저장

그 다음 내려주어야 할 데이터를 추출 방법에 대해 생각해보았다.
ex) oldTime[0] = 10100010 이고,
    newTime[0] = 10001010 이라면 곂쳐있는 1은 움직이지 않고 old에는 1 new에는 0이면 내려주어야 한다.

방법은 ~newTime[arr]&oldTime[arr]를 해주면 내려줘야 하는 위치를 찾을 수 있다.
ex) oldTime[0] = 10100010
    newTime[0] = 10001010, ~newTime[0] = 01110101
    ~newTime[0](01110101) &(AND)
     oldTime[0](10100010) = 00100000-> down 변수에 저장
```C++
up = (~newTime[i])^oldTime[i];
down = (~newTime[i])&oldTime[i];
```
down 변수는 00/10/00/00일 때 비트에서 첫번째 비트가 1이면 해당 비트를 0으로 만들어주고 다음 두번째 비트를 1로 만들어 주어야 한다. 해당 모터는 내려주어야 하기 때문에 왼쪽으로 돌려주어야 하기 때문이다.

그래서 내가 생각 한 방법은 for문을 통해서 down의 해당 비트가 1이면 0으로 초기화하고 다음 비트를 1로 설정하는 방법을 생각했다.
ex) down = 00/10/00/00 이라면 for문 이후에는 00/01/00/00으로 저장된다.
```C++
for(int j=0; j<=7; j+=2) {
  if(bitRead(down, 7-j)) {
    bitClear(down, 7-j);
    bitSet(down, 7-(j+1));
  }
}
```
이렇게 해서 up|down 값은 내려주는 위치와 올려주는 위치를 한번에 알 수 있게된다.

## 결론
엘레베이터를 10층에서 타고 1층으로 내려가는 중에 5층과 3층에서 내려가는 버튼이 눌렸다면 해당 위치에서 정지 후 엘레베이터는 다시 내려가는 동작을 하게된다. 만약 엘레베이터가 정지하지 않고 1층까지 내려갔다가 다시 5층을 가서 정지 후 다시 1층.. 그리고 3층으로 가서 정지 후 다시 1층.. 얼마나 비효율적인가?
이번에 모터를 이렇게 위치데이터를 추출하려고 했던 것도 같은 이유에서였다.
모터를 전부 내려주고 다시 해당하는 값을 올리는 작업을 할 수도 있지만, 몇가지 동작을 줄일 수 있다면 전력소모도 크게 줄어들 것이다.
정말 간단한 방법이지만 왠지 모르게 값 추출하는 연산을 고민하는데 꽤나 오래걸렸다.. 그래도 고민하는 과정이 재미있었다.
